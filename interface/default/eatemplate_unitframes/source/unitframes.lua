--[[
    The stately and pompous UnitFrames...manager of all UnitFrame objects
--]]

UnitFrames = 
{
    -- Holds UnitFrameObject creators.  These creators are user-specified.
    -- A few default creators are specified by default.
    m_UnitFrameObjectFactory = {},
    
    -- Holds UnitFrame entries, indexed by UnitId (keys generated by compositing UnitId strings.)
    -- Such as:
    -- "self"                               : Refers to the player
    -- "selfpet"                            : Refers to the player's pet 
    -- "group1friendlytargethostiletarget"  : Refers to groupmate1's ally's hostile target. 
    -- etc...
    m_UnitIdToFrameMapping = {},
    
    -- Constants for specifying what type of UnitFrame to create
    UNITFRAME_TARGET                = "TargetUnitFrame",
    UNITFRAME_MOUSEOVER_TARGET      = "MouseOverTargetUnitFrame",
    UNITFRAME_GROUP_MEMBER          = "GroupMemberUnitFrame",
    UNITFRAME_PLAYER_PET            = "PlayerPetUnitFrame",
    UNITFRAME_GROUP_PET             = "GroupPetUnitFrame",
}

--
-- The "WorkAround" functions exist because it is apparently not possible to 
-- call UnitFrames methods from the client with the colon-syntax.
--
-- ie, in EATemplate_UnitFrames.mod doing something like:
--
-- <OnInitialize>
--     <CallFunction name="UnitFrames:Initialize" /> 
-- </OnInitialize>  
--
-- just won't work.  Hence the "WorkArounds" until I find a better way...
--
function UnitFrames.InitializeProxy ()
    UnitFrames:Initialize ()
end

function UnitFrames.ShutdownProxy ()
    UnitFrames:Shutdown ()
end

function UnitFrames.UpdateProxy (timePassed)
    UnitFrames:Update (timePassed)
end

--
-- Initialize UnitFrames, the manager of all the UnitFrames in the interface.
-- Populates the initial table with all the default unit frame types that can be created.
--
function UnitFrames:Initialize ()
    self:AddFrameFactory (self.UNITFRAME_TARGET, TargetUnitFrame)
    self:AddFrameFactory (self.UNITFRAME_MOUSEOVER_TARGET, MouseOverTargetUnitFrame)
    self:AddFrameFactory (self.UNITFRAME_GROUP_MEMBER, GroupMemberUnitFrame)
    self:AddFrameFactory (self.UNITFRAME_GROUP_PET, GroupPetUnitFrame)
    self:AddFrameFactory (self.UNITFRAME_PLAYER_PET, PlayerPetUnitFrame)
end

--
-- Kills all the managed unit frames 
--
function UnitFrames:Shutdown ()
    self:Destroy ()
end

function UnitFrames:Update (timePassed)
    for unitId, frameObject in pairs (self.m_UnitIdToFrameMapping)
    do
        frameObject:Update (timePassed)
    end
end

--
-- Allows new frame factories to be created
--
function UnitFrames:AddFrameFactory (frameType, frameFactory)
    self.m_UnitFrameObjectFactory[frameType] = frameFactory
end

--
-- Utility function to find the proper UnitFrame for a UnitId.  
-- Can return nil if the UnitFrame doesn't exist.  
-- ie, it's possible that the UnitFrame for the player's target's target's target's target 
-- hasn't been created. :)
--
function UnitFrames:UnitFrameFromUnitId (unitId)
    if (unitId ~= nil)
    then
        return self.m_UnitIdToFrameMapping[unitId]
    end
    
    return nil
end

--
-- Utility function to add a frame to the unit frame mapping
--
function UnitFrames:AddFrame (unitId, unitFrame)
    if (unitId ~= nil and unitFrame ~= nil)
    then
        -- Destroy existing unit frame before overwriting!!
        local preExistingFrameObject = self.m_UnitIdToFrameMapping[unitId]
        
        if (preExistingFrameObject ~= nil)
        then
            preExistingFrameObject:Destroy ()
        end

        self.m_UnitIdToFrameMapping[unitId] = unitFrame
        return unitFrame
    end
    
    return nil
end

--
-- Frame Objects create themselves.  These are the actual tables that contain
-- the logic for setting up their own windows.  UnitFrames is just an object
-- that manages the frames it contains, but does not attempt to perform any
-- of the operations like SetName, SetHealth, etc...
-- Those operations are managed by the UnitFrameObject.
-- If the user wishes to make a completely new sort of unit frame, UnitFrames
-- contains a facility to allow the user to register new a new factory
-- method with it, so that a frameType will map to the desired factory method.
--

--
-- Creates a new UnitFrame window, associates it with a UnitId
-- and adds it to the UnitFrame table.
--
function UnitFrames:CreateNewFrame (windowName, frameType, unitId)   
    local factory       = self.m_UnitFrameObjectFactory[frameType]
    local frameObject   = nil
    
    if (factory ~= nil)
    then
        frameObject = factory:Create (windowName, unitId)
    end

    if (frameObject == nil)
    then
        return nil
    end
    return self:AddFrame (unitId, frameObject)
end

--
-- Stops tracking a UnitFrame and destroys system resources associated with it
-- External function should not pass a second parameter to the function.
-- Modifying m_UnitIdToFrameMapping while it is being iterated over with pairs
-- is probably a bad idea, so do not remove things from that map when called
-- from Destroy().
--
UnitFrames.REMOVE_DESTROYED_FRAME = 1
UnitFrames.RETAIN_DESTROYED_FRAME = 2

function UnitFrames:DestroyFrame (unitId, removalFlag)
    if (unitId ~= nil)
    then
        local frameObject = self.m_UnitIdToFrameMapping[unitId]

        if (frameObject ~= nil)
        then
            frameObject:Destroy ()

            if (removalFlag == UnitFrames.REMOVE_DESTROYED_FRAME)
            then
                self.m_UnitIdToFrameMapping[unitId] = nil
            end
        end
    end
end

--
-- Destroys all UnitFrames
--
function UnitFrames:Destroy ()
    for unitId, frameObject in pairs (self.m_UnitIdToFrameMapping)
    do
        self:DestroyFrame (unitId, UnitFrames.RETAIN_DESTROYED_FRAME)
    end
    
    self.m_UnitIdToFrameMapping = { }
end
